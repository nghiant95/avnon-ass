import { createAction, props, on, createReducer, createSelector, createFeatureSelector } from '@ngrx/store';
import { produce } from 'immer';

function createSliceActions(featureName, sliceActionNameGetter, reducers, reducersToActions) {
    const actions = {};
    actions['noop'] = createAction(reducersToActions?.['noop'] ||
        sliceActionNameGetter(featureName, 'noop effect'), props());
    for (const [reducerKey, reducerValue] of Object.entries(reducers)) {
        const typeOfReducer = typeof reducerValue;
        const sliceActionName = reducersToActions?.[reducerKey] ||
            sliceActionNameGetter(featureName, reducerKey);
        if (typeOfReducer === 'function') {
            actions[reducerKey] = createAction(sliceActionName, props());
            continue;
        }
        actions[reducerKey] = {};
        Object.keys(reducerValue).forEach((asyncKey) => {
            actions[reducerKey][asyncKey] =
                createAction(`${sliceActionName} ${asyncKey}`, props());
        });
    }
    return actions;
}

function createSliceReducer(initialState, actions, reducers, extraReducers) {
    const reducerArgs = [];
    const extra = (extraReducers || []);
    for (const [reducerKey, reducer] of Object.entries(reducers)) {
        const typeOfReducer = typeof reducer;
        if (typeOfReducer === 'function') {
            reducerArgs.push(on(actions[reducerKey], (state, payload) => produce(state, (draft) => reducer(draft, payload))));
            continue;
        }
        Object.keys(reducer).forEach((asyncKey) => {
            const asyncReducer = reducer[asyncKey];
            reducerArgs.push(on(actions[reducerKey][asyncKey], (state, payload) => produce(state, (draft) => asyncReducer(draft, payload))));
        });
    }
    return createReducer(initialState, ...reducerArgs.concat(extra));
}

function isDictionary(arg) {
    return (typeof arg === 'object' &&
        arg !== null &&
        !Array.isArray(arg) &&
        !(arg instanceof Date));
}

const STRING_CAMELIZE_REGEXP = /(-|_|\.|\s)+(.)?/g;
/**
 Returns the lowerCamelCase form of a string.
 ```javascript
 camelize('innerHTML');          // 'innerHTML'
 camelize('action_name');        // 'actionName'
 camelize('css-class-name');     // 'cssClassName'
 camelize('my favorite items');  // 'myFavoriteItems'
 camelize('My Favorite Items');  // 'myFavoriteItems'
 ```
 @method camelize
 @param {String} str The string to camelize.
 @return {String} the camelized string.
 */
function camelize(str) {
    return str
        .replace(STRING_CAMELIZE_REGEXP, (_match, _separator, chr) => {
        return chr ? chr.toUpperCase() : '';
    })
        .replace(/^([A-Z])/, (match) => match.toLowerCase());
}
/**
 Returns the UpperCamelCase form of a string.
 ```javascript
 'innerHTML'.classify();          // 'InnerHTML'
 'action_name'.classify();        // 'ActionName'
 'css-class-name'.classify();     // 'CssClassName'
 'my favorite items'.classify();  // 'MyFavoriteItems'
 ```
 @method classify
 @param {String} str the string to classify
 @return {String} the classified string
 */
function classify(str) {
    return str
        .split('.')
        .map((part) => capitalize(camelize(part)))
        .join('.');
}
/**
 Returns the Capitalized form of a string
 ```javascript
 'innerHTML'.capitalize()         // 'InnerHTML'
 'action_name'.capitalize()       // 'Action_name'
 'css-class-name'.capitalize()    // 'Css-class-name'
 'my favorite items'.capitalize() // 'My favorite items'
 ```
 @method capitalize
 @param {String} str The string to capitalize.
 @return {String} The capitalized string.
 */
function capitalize(str) {
    return (str.charAt(0).toUpperCase() +
        str.substring(1));
}

function createSliceSelectors(initialState, featureSelector) {
    const nestedKeys = (isDictionary(initialState) ? Object.keys(initialState) : []);
    return nestedKeys.reduce((nestedSelectors, nestedKey) => ({
        ...nestedSelectors,
        [`select${classify(nestedKey)}`]: createSelector(featureSelector, (parentState) => parentState[nestedKey]),
    }), {});
}

function defaultSliceActionNameGetter(featureName, actionName) {
    return `[${classify(featureName)}] ${actionName}`;
}
function noopReducer() {
    return (() => { });
}
function createSlice({ name, initialState, reducers, extraReducers, reducersToActions, sliceActionNameGetter = defaultSliceActionNameGetter, }) {
    const featureSelector = createFeatureSelector(name);
    const nestedSelectors = createSliceSelectors(initialState, featureSelector);
    const actions = createSliceActions(name, sliceActionNameGetter, reducers, reducersToActions);
    const reducer = createSliceReducer(initialState, actions, reducers, extraReducers);
    return {
        name,
        reducer,
        actions,
        selectors: {
            [`select${classify(name)}State`]: featureSelector,
            ...nestedSelectors,
        },
    };
}
function createNamespacedSlice({ name, initialState, reducers, extraReducers, reducersToActions, sliceActionNameGetter = defaultSliceActionNameGetter, }) {
    const { name: sliceName, reducer, selectors, actions, } = createSlice({
        name,
        initialState,
        reducers,
        extraReducers,
        reducersToActions,
        sliceActionNameGetter,
    });
    const classifiedName = classify(name);
    return {
        [`${classifiedName}Feature`]: {
            name: sliceName,
            reducer,
        },
        [`${classifiedName}Actions`]: actions,
        [`${classifiedName}Selectors`]: selectors,
    };
}

/*
 * Public API Surface of ngrx-slice
 */

/**
 * Generated bundle index. Do not edit.
 */

export { createNamespacedSlice, createSlice, noopReducer };
//# sourceMappingURL=ngrx-slice.mjs.map
